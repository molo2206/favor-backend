import {
  BadRequestException,
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { IsNull, Repository } from 'typeorm';
import { CreateCategoryDto } from './dto/create-category.dto';
import { CategoryEntity } from './entities/category.entity';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { slugify } from 'src/users/utility/slug/slugify';
import { CloudinaryService } from 'src/users/utility/helpers/cloudinary.service';
import { In } from 'typeorm';
import { CategorySpecification } from 'src/specification/entities/CategorySpecification.entity';
import { CategorySpecificationService } from 'src/specification/category-specification.service';
import { CategoryAttribute } from 'src/AttributGlobal/entities/category_attributes.entity';
import { Attribute } from 'src/AttributGlobal/entities/attributes.entity';

@Injectable()
export class CategoryService {
  constructor(
    @InjectRepository(CategoryEntity)
    private readonly categoryRepo: Repository<CategoryEntity>,

    @InjectRepository(CategorySpecification)
    private readonly categorySpecificationRepo: Repository<CategorySpecification>,

    @InjectRepository(CategoryAttribute)
    private readonly categoryAttributeRepo: Repository<CategoryAttribute>,

    @InjectRepository(Attribute)
    private readonly globalAttrRepo: Repository<Attribute>,

    private readonly categorySpecification: CategorySpecificationService,

    private readonly cloudinary: CloudinaryService,
  ) {}

  async create(
    createCategoryDto: CreateCategoryDto,
    file: Express.Multer.File,
  ): Promise<{ message: string; data: CategoryEntity }> {
    const { name, parentId, type, color, specifications, attributes } = createCategoryDto;

    // V√©rifie si une cat√©gorie avec ce nom et type existe d√©j√†
    const existingCategory = await this.categoryRepo.findOne({ where: { name, type } });
    if (existingCategory) {
      throw new ConflictException('Une cat√©gorie avec ce nom et ce type existe d√©j√†');
    }

    // V√©rifie la cat√©gorie parente
    let parent: CategoryEntity | undefined = undefined;
    if (parentId) {
      const foundParent = await this.categoryRepo.findOne({ where: { id: parentId } });
      if (!foundParent) throw new NotFoundException('Cat√©gorie parente non trouv√©e');
      parent = foundParent;
    }

    // G√©n√®re un slug unique
    let slug = slugify(name, { lower: true, strict: true });
    const existingSlug = await this.categoryRepo.findOne({ where: { slug } });
    if (existingSlug) {
      const uniqueSuffix = Date.now().toString().slice(-5);
      slug = `${slug}-${uniqueSuffix}`;
    }

    // V√©rifie la pr√©sence du fichier image
    if (!file) throw new BadRequestException('Une image est requise pour cr√©er une cat√©gorie.');
    const imageUrl = await this.cloudinary.handleUploadImage(file, 'category');

    // Cr√©e la cat√©gorie
    const category = this.categoryRepo.create({
      name,
      slug,
      type,
      color,
      parent: parent ?? undefined, // üîπ correction pour TypeORM
      image: imageUrl,
    });

    const savedCategory = await this.categoryRepo.save(category);

    // üîπ Lier les sp√©cifications
    if (specifications && Array.isArray(specifications)) {
      for (const spec of specifications) {
        await this.categorySpecification.addSpecificationToCategory(
          savedCategory.id,
          spec.specificationId,
          spec.required || false,
        );
      }
    }

    // üîπ Lier les attributs globaux
    if (attributes && Array.isArray(attributes)) {
      const relations: CategoryAttribute[] = [];
      for (const attr of attributes) {
        const attribute = await this.globalAttrRepo.findOne({
          where: { id: attr.attribute_id },
        });
        if (!attribute)
          throw new NotFoundException(`Attribut ${attr.attribute_id} introuvable`);

        const relation = this.categoryAttributeRepo.create({
          category: { id: savedCategory.id }, // üîπ correction ici
          attribute,
        });
        relations.push(relation);
      }
      await this.categoryAttributeRepo.save(relations); // insertion r√©elle
    }

    // üîπ Charger toutes les relations pour le retour
    const categoryWithRelations = await this.categoryRepo.findOne({
      where: { id: savedCategory.id },
      relations: [
        'parent',
        'children',
        'specifications',
        'specifications.specification',
        'categoryAttributes',
        'categoryAttributes.attribute',
      ],
    });

    return {
      message: 'Cat√©gorie enregistr√©e avec succ√®s',
      data: categoryWithRelations!,
    };
  }

  async update(
    id: string,
    updateCategoryDto: UpdateCategoryDto,
    file?: Express.Multer.File,
  ): Promise<{ message: string; data: CategoryEntity }> {
    const category = await this.categoryRepo.findOne({ where: { id } });
    if (!category) throw new NotFoundException('Cat√©gorie introuvable');

    const { name, parentId, type, color, specifications, attributes } = updateCategoryDto;

    // ‚úÖ V√©rifier unicit√© nom + type
    if (name && type) {
      const existingCategory = await this.categoryRepo.findOne({ where: { name, type } });
      if (existingCategory && existingCategory.id !== id) {
        throw new ConflictException('Une cat√©gorie avec ce nom et ce type existe d√©j√†');
      }
    }

    // ‚úÖ Mise √† jour des champs de base
    if (name) {
      category.name = name;
      category.slug = slugify(name, { lower: true, strict: true });
    }
    if (type) category.type = type;
    if (color) category.color = color;

    if (parentId) {
      const parent = await this.categoryRepo.findOne({ where: { id: parentId } });
      if (!parent) throw new NotFoundException('Cat√©gorie parente non trouv√©e');
      category.parent = parent;
    }

    // ‚úÖ Image
    if (file) {
      const imageUrl = await this.cloudinary.handleUploadImage(file, 'category');
      category.image = imageUrl;
    }

    // ‚úÖ Sauvegarder la cat√©gorie
    const updatedCategory = await this.categoryRepo.save(category);

    // üîπ Gestion des specifications
    if (specifications && Array.isArray(specifications)) {
      await this.categorySpecification.removeAllSpecificationsFromCategory(updatedCategory.id);

      for (const spec of specifications) {
        if (!spec.specificationId) {
          throw new BadRequestException(
            'Chaque specification doit contenir un specificationId',
          );
        }
        await this.categorySpecification.addSpecificationToCategory(
          updatedCategory.id,
          spec.specificationId,
          spec.required ?? false,
        );
      }
    }

    // üîπ Gestion des attributes
    if (attributes && Array.isArray(attributes)) {
      // Supprimer les anciennes relations si existantes
      await this.categoryAttributeRepo.delete({ category: { id: updatedCategory.id } });

      const relations: CategoryAttribute[] = [];
      for (const attr of attributes) {
        const attribute = await this.globalAttrRepo.findOne({
          where: { id: attr.attribute_id },
        });
        if (!attribute)
          throw new NotFoundException(`Attribut ${attr.attribute_id} introuvable`);

        const relation = this.categoryAttributeRepo.create({
          category: updatedCategory,
          attribute,
        });
        relations.push(relation);
      }
      await this.categoryAttributeRepo.save(relations); // insertion r√©elle
    }

    // ‚úÖ Charger toutes les relations pour la r√©ponse
    const categoryWithRelations = await this.categoryRepo.findOne({
      where: { id: updatedCategory.id },
      relations: [
        'parent',
        'children',
        'specifications',
        'specifications.specification',
        'categoryAttributes',
        'categoryAttributes.attribute',
      ],
    });

    return {
      message: 'Cat√©gorie mise √† jour avec succ√®s',
      data: categoryWithRelations!,
    };
  }

  async findAll(type?: string): Promise<CategoryEntity[]> {
    const queryBuilder = this.categoryRepo
      .createQueryBuilder('category')
      .leftJoinAndSelect('category.parent', 'parent')
      .leftJoinAndSelect('category.children', 'children')
      .leftJoinAndSelect('category.specifications', 'categorySpec')
      .leftJoinAndSelect('categorySpec.specification', 'specification')
      .leftJoinAndSelect('category.categoryAttributes', 'categoryAttribute')
      .leftJoinAndSelect('categoryAttribute.attribute', 'attribute'); // attribut global

    if (type) {
      queryBuilder.where('category.type = :type', { type });
    }

    const categories = await queryBuilder.getMany();
    return categories;
  }

  async findAllParent(type?: string): Promise<CategoryEntity[]> {
    const queryBuilder = this.categoryRepo
      .createQueryBuilder('category')
      .leftJoinAndSelect('category.children', 'children')
      .leftJoinAndSelect('category.specifications', 'categorySpec')
      .leftJoinAndSelect('categorySpec.specification', 'specification')
      .leftJoinAndSelect('category.categoryAttributes', 'categoryAttribute')
      .leftJoinAndSelect('categoryAttribute.attribute', 'attribute')
      .where('category.parent IS NULL');

    if (type) {
      queryBuilder.andWhere('category.type = :type', { type });
    }

    const categories = await queryBuilder.getMany();
    return categories;
  }

  async findOne(id: string): Promise<CategoryEntity> {
    const category = await this.categoryRepo.findOne({
      where: { id },
      relations: [
        'parent',
        'children',
        'specifications',
        'specifications.specification',
        'categoryAttributes',
        'categoryAttributes.attribute',
      ],
    });

    if (!category) {
      throw new NotFoundException(`Cat√©gorie introuvable avec l'id: ${id}`);
    }

    return category;
  }

  async findByTypeCompany(type: string): Promise<CategoryEntity[]> {
    const categories = await this.categoryRepo.find({
      where: { type },
      relations: [
        'parent',
        'children',
        'specifications',
        'specifications.specification',
        'categoryAttributes',
        'categoryAttributes.attribute',
      ],
    });

    if (!categories.length) {
      throw new NotFoundException(
        `Aucune cat√©gorie trouv√©e pour le type d‚Äôentreprise avec l'id: ${type}`,
      );
    }

    return categories;
  }

  async findByParentId(parentId: string | null): Promise<CategoryEntity[]> {
    const whereClause = parentId ? { parent: { id: parentId } } : { parent: IsNull() };

    const categories = await this.categoryRepo.find({
      where: whereClause,
      relations: [
        'parent',
        'children',
        'specifications',
        'specifications.specification',
        'categoryAttributes',
        'categoryAttributes.attribute',
      ],
    });

    if (!categories.length) {
      throw new NotFoundException(
        `Aucune cat√©gorie trouv√©e avec le parent "${parentId ?? 'null'}"`,
      );
    }

    return categories.map((category) => ({
      ...category,
      numberOfChildren: category.children.length,
    }));
  }

  async remove(id: string): Promise<{ data: string }> {
    // R√©cup√®re la cat√©gorie √† supprimer
    const category = await this.findOne(id);

    // Supprimer directement l'entit√©
    await this.categoryRepo.remove(category);

    return { data: `Category with id ${id} removed successfully` };
  }

  async getSpecificationsByCategoryId(categoryId: string) {
    const category = await this.categoryRepo.findOne({
      where: { id: categoryId },
    });

    if (!category) {
      throw new NotFoundException(`Cat√©gorie avec l'ID ${categoryId} non trouv√©e`);
    }

    // Utiliser Query Builder avec le bon nom de relation
    const categorySpecs = await this.categorySpecificationRepo
      .createQueryBuilder('cs')
      .leftJoinAndSelect('cs.specification', 'spec') // Utiliser leftJoinAndSelect au lieu de innerJoinAndSelect
      .where('cs.categoryId = :categoryId', { categoryId })
      .andWhere('spec.deleted = :deleted', { deleted: false })
      .orderBy('cs.displayOrder', 'ASC')
      .getMany();

    if (!categorySpecs.length) {
      return {
        message: `Aucune sp√©cification trouv√©e pour la cat√©gorie "${category.name}"`,
        data: [],
      };
    }

    const data = categorySpecs.map((cs) => ({
      categorySpecificationId: cs.id,
      categoryId: cs.categoryId,
      specificationId: cs.specificationId,
      required: cs.required,
      displayOrder: cs.displayOrder,
      specification: cs.specification
        ? {
            id: cs.specification.id,
            key: cs.specification.key,
            label: cs.specification.label,
            type: cs.specification.type,
            unit: cs.specification.unit,
            options: cs.specification.options,
          }
        : null,
    }));

    return {
      message: `Sp√©cifications r√©cup√©r√©es avec succ√®s`,
      data,
      count: data.length,
    };
  }

  async getAttributesByCategoryId(categoryId: string) {
    // V√©rifie si la cat√©gorie existe
    const category = await this.categoryRepo.findOne({ where: { id: categoryId } });
    if (!category) {
      throw new NotFoundException(`Cat√©gorie avec l'ID ${categoryId} non trouv√©e`);
    }

    // R√©cup√®re les attributs li√©s √† la cat√©gorie avec jointure sur la cat√©gorie et l'attribut
    const categoryAttrs = await this.categoryAttributeRepo
      .createQueryBuilder('ca')
      .leftJoinAndSelect('ca.attribute', 'attr') // jointure pour les attributs
      .leftJoinAndSelect('ca.category', 'category') // jointure pour la cat√©gorie
      .where('ca.category_id = :categoryId', { categoryId }) // utilise le nom correct de la colonne
      .orderBy('attr.name', 'ASC') // ‚úÖ Utiliser 'name' au lieu de 'label'
      .getMany();

    if (!categoryAttrs.length) {
      return {
        message: `Aucun attribut trouv√© pour la cat√©gorie "${category.name}"`,
        data: [],
      };
    }

    // Transforme les r√©sultats pour la r√©ponse - CORRIG√â selon l'entit√© Attribute
    const data = categoryAttrs.map((ca) => ({
      categoryAttributeId: ca.id,
      categoryId: ca.category.id, // r√©cup√©r√© via la jointure
      attributeId: ca.attribute.id,
      attribute: {
        id: ca.attribute.id,
        name: ca.attribute.name, // ‚úÖ Utiliser 'name' au lieu de 'key' et 'label'
        slug: ca.attribute.slug, // ‚úÖ Propri√©t√© existante
        type: ca.attribute.type, // ‚úÖ Propri√©t√© existante
        description: ca.attribute.description, // ‚úÖ Propri√©t√© existante
        isRequired: ca.attribute.isRequired, // ‚úÖ Propri√©t√© existante
        isFilterable: ca.attribute.isFilterable, // ‚úÖ Propri√©t√© existante
      },
      createdAt: ca.createdAt,
    }));

    return {
      message: `Attributs r√©cup√©r√©s avec succ√®s pour la cat√©gorie "${category.name}"`,
      data,
      count: data.length,
    };
  }

  async findAllWithProducts(companyId: string, type?: string) {
    const queryBuilder = this.categoryRepo
      .createQueryBuilder('category')
      .leftJoinAndSelect('category.parent', 'parent')
      .leftJoinAndSelect('category.children', 'children')
      .leftJoinAndSelect('category.specifications', 'categorySpec')
      .leftJoinAndSelect('categorySpec.specification', 'specification')
      .leftJoinAndSelect('category.categoryAttributes', 'categoryAttribute')
      .leftJoinAndSelect('categoryAttribute.attribute', 'attribute')
      // join avec produits filtr√©s par companyId
      .leftJoinAndSelect('category.products', 'product', 'product.companyId = :companyId', {
        companyId,
      })
      // toutes les relations du produit
      .leftJoinAndSelect('product.images', 'images')
      .leftJoinAndSelect('product.measure', 'measure')
      .leftJoinAndSelect('product.rentalContracts', 'rentalContracts')
      .leftJoinAndSelect('product.saleTransactions', 'saleTransactions')
      .leftJoinAndSelect('product.specificationValues', 'specificationValues')
      .leftJoinAndSelect('specificationValues.specification', 'specificationDetail') // si tu veux le d√©tail
      .leftJoinAndSelect('product.attributes', 'attributes')
      .leftJoinAndSelect('product.wishlist', 'wishlist')
      .leftJoinAndSelect('product.company', 'company')
      .leftJoinAndSelect('company.country', 'country')
      .leftJoinAndSelect('company.city', 'city');

    if (type) {
      queryBuilder.andWhere('category.type = :type', { type });
    }

    queryBuilder.orderBy('category.name', 'ASC');

    const categories = await queryBuilder.getMany();

    // On ne garde que les cat√©gories avec au moins un produit
    const categoriesWithProducts = categories.filter((c) => c.products?.length);

    return {
      message: categoriesWithProducts.length
        ? 'Cat√©gories avec produits r√©cup√©r√©es avec succ√®s.'
        : 'Aucune cat√©gorie avec produit trouv√©.',
      data: categoriesWithProducts,
    };
  }
}
